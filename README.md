**Keepr2 Project Repository**

This repository is a rebuild of the final project from the Spring 2025 Immersive Full-Stack Web Development Course from Boise CodeWorks (BCW). This project is a very good final for the course that incorporates a Vue.js front end for HTML5/CSS3/Javascript with a C#/.net backend communicating with a mySQL database. After the course ended I had some commitments that I needed to keep for a few weeks and didn't have much time to continue practicing building web applications, so I wanted to rebuild this project to get some more practice in before moving on to other challenges. I plan on writing this readme to document my process in building the application as well as my thoughts on challenges faced.

**Project Concept**

This propject is intended to be a clone of the basic concept of Pinterest (I say basic only because I've never really used Pinterest myself so I don't know all of the functionality that it may have today). It allows users to create an account and upload images ("keeps") along with a title and description that users can save to their own collections ("vaults", I believe in Pinterest they are called "boards"?). Users also have the option to make their vaults private so that that are the only ones who can see them. The number of times a keep is viewed and saved to a vault is also kept track of.

**Starting Out**

I decided to start the project out a little differently this time around. On the final I would create a feature branch for the feature I was going to build (let's say for keeps) and then I would create what I needed as I went, ie. class models, database tables, interfaces, etc. This time I decided to start out by creating feature branches specifically for the task of creating all server side class models, database tables, interfaces, etc., so that I would have all them ready for when I started working on future feature branches, like keeps, vaults, etc.

I felt I liked this approach more than the previous one. This allowed me to have everything ready when creating each new functional part of the web app, instead of making them as I went. While I don't think either approach is bad, on the final I ran into a couple situations where say, I would need a class model that I hadn't created yet to finish out everything for the feature branch (ie. I would need to make a Profile class model to use for methods in my keeps branch). I would then need to create the Profile class model while working on my keeps branch. While this probably isn't inherently a problem, I feel like this better fulfills the intent of feature branches. Separating work by the feature you are working on instead of making this as you go.

**Interfaces**

During the course we learned how to create and use interfaces in C#. I used a few interfaces on the final that implemented common CRUD methods (Create, Get/GetAll, Update, and Delete). I made an interface for Controllers, Services, and Repositories. These problem I found by making them this way was not every controller needed all of the same methods, and so on for services and repos, so there would be extra methods that aren't implemented and just exist (the only methods that were common between files were a Create and Delete method). While this doesn't cause any functional issues with the application that I'm aware of, it definitely looks less tidy, and there is no purpose to have extra code lying around that can't be accessed.

This time I created interfaces for each controller, service, and repo that I was going to make, and gave each of them only the methods that they would need. I understand this isn't really the intent for what interfaces are generally for, being that you have multiple things that will all have common methods that you want to make sure they all have, and then you build upon each of them in each file you implement them in (an example being you have an animal interface that has methods that all animals are going to have (name, species, numberOFLegs, food, etc.), but a dog animal will have a bark method, whereas a cat will have a meow method). However, I enjoyed learning how to use interfaces and enjoyed using them in this was as just a different means of structuring my application. I had fun experimenting with this way of using them.
