**Keepr2 Project Repository**

This repository is a rebuild of the final project from the Spring 2025 Immersive Full-Stack Web Development Course from Boise CodeWorks (BCW). This project is a very good final for the course that incorporates a Vue.js front end for HTML5/CSS3/Javascript with a C#/.net backend communicating with a mySQL database. After the course ended I had some commitments that I needed to keep for a few weeks and didn't have much time to continue practicing building web applications, so I wanted to rebuild this project to get some more practice in before moving on to other challenges. I plan on writing this readme to document my process in building the application as well as my thoughts on challenges faced.

**Project Concept**

This propject is intended to be a clone of the basic concept of Pinterest (I say basic only because I've never really used Pinterest myself so I don't know all of the functionality that it may have today). It allows users to create an account and upload images ("keeps") along with a title and description that users can save to their own collections ("vaults", I believe in Pinterest they are called "boards"?). Users also have the option to make their vaults private so that that are the only ones who can see them. The number of times a keep is viewed and saved to a vault is also kept track of.

**Starting Out**

I decided to start the project out a little differently this time around. On the final I would create a feature branch for the feature I was going to build (let's say for keeps) and then I would create what I needed as I went, ie. class models, database tables, interfaces, etc. This time I decided to start out by creating feature branches specifically for the task of creating all server side class models, database tables, interfaces, etc., so that I would have all them ready for when I started working on future feature branches, like keeps, vaults, etc.

I felt I liked this approach more than the previous one. This allowed me to have everything ready when creating each new functional part of the web app, instead of making them as I went. While I don't think either approach is bad, on the final I ran into a couple situations where say, I would need a class model that I hadn't created yet to finish out everything for the feature branch (ie. I would need to make a Profile class model to use for methods in my keeps branch). I would then need to create the Profile class model while working on my keeps branch. While this probably isn't inherently a problem, I feel like this better fulfills the intent of feature branches. Separating work by the feature you are working on instead of making this as you go.

**Interfaces**

During the course we learned how to create and use interfaces in C#. I used a few interfaces on the final that implemented common CRUD methods (Create, Get/GetAll, Update, and Delete). I made an interface for Controllers, Services, and Repositories. These problem I found by making them this way was not every controller needed all of the same methods, and so on for services and repos, so there would be extra methods that aren't implemented and just exist (the only methods that were common between files were a Create and Delete method). While this doesn't cause any functional issues with the application that I'm aware of, it definitely looks less tidy, and there is no purpose to have extra code lying around that can't be accessed.

This time I created interfaces for each controller, service, and repo that I was going to make, and gave each of them only the methods that they would need. I understand this isn't really the intent for what interfaces are generally for, being that you have multiple things that will all have common methods that you want to make sure they all have, and then you build upon each of them in each file you implement them in (an example being you have an animal interface that has methods that all animals are going to have (name, species, numberOFLegs, food, etc.), but a dog animal will have a bark method, whereas a cat will have a meow method). However, I enjoyed learning how to use interfaces and enjoyed using them in this was as just a different means of structuring my application. I had fun experimenting with this way of using them.

**Branches**

While working on this project as a solo dev it is not strictly necessary to make branches off of the main, I feel it's good to foster that habit even when working solo as I can only benefit from it when I work on teams. It technically could be more complex in certain situations (say if I forgot to create something in my "keeps" branch that I need in my "vaults" branch that I am currently working in), however, I still think it is worth coding in this way to keep the different features of this webapp in their lane, so to speak.

An example of this happened on this project, actually. I had started out the project by making a branch to create all of the class models I would need for my server. Afterward I merged it into main and moved on to new branches for other features. A few branches down the road I was working on my "keeps" branch, which entailed backend and frontend features relating to "keeps" specifically. When I finished the backend and was moving to the frontend I realized I had forgotten to make a branch to create all of the client side class models. I could have justified creating what models I needed that related to "keeps" in this branch, but I wanted to follow the structure I had set up previously by making a branch for it.

I could of course just branch out from main again to make the client class models branch, but then I still wouldn't have them available in the current "keeps" branch. I spoke with my brother (who is a web developer) and he explained that I could branch off of main to make my client class models branch, complete it and merge it back to main, and then merge main into my current "keeps" branch. Afterward I felt like "duh, of course I could do that!", but up until then I hadn't had a reason to think in that direction. I hadn't had an occasion to think of merging any direciton other than branch -> main. I'm thankful when these kinds of roadblocks come my way that help me see a new way of doing things/opening my mind to ways of working around problems that I hadn't thought of before. I know several software devs in my personal life and I'm thankful to them for being willing to take me under their wing and teach me.
